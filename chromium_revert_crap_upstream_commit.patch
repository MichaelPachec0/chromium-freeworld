From 3ec3b2992238d4b4764f99f04605e154688c7990 Mon Sep 17 00:00:00 2001
From: Ted Meyer <tmathmeyer@chromium.org>
Date: Fri, 18 Jun 2021 04:56:47 +0000
Subject: [PATCH] Roll src/third_party/ffmpeg/ 7e1d53a09..cf7ee6598 (1000
 commits)

https://chromium.googlesource.com/chromium/third_party/ffmpeg.git/+log/7e1d53a09f9a..cf7ee6598c6f

$ git log 7e1d53a09..cf7ee6598 --date=short --no-merges --format='%ad %ae %s'
2021-06-14 tmathmeyer Remove avcodec_decode_video2 from sigs
2021-06-04 tmathmeyer Initialize variables to fix compilation warning
2021-06-02 tmathmeyer Cherry pick change from ffmpeg::master onto sushi branch for roll
2021-05-15 tmathmeyer Update FFMpeg
2021-05-07 ffmpeg doc/muxers: note movie_timescale option in movenc
(...)
2021-03-10 andreas.rheinhardt dnn/dnn_backend_native: Fix typo in log message
2021-03-10 andreas.rheinhardt dnn/dnn_backend_native: Don't use asserts for checks
2021-03-10 andreas.rheinhardt dnn/dnn_backend_native: Fix leak in case parsing options fails
2021-03-10 andreas.rheinhardt dnn/dnn_backend_native: Avoid allocation for checking file magic
2021-03-10 jb Doc: Tech Resolution Process

Created with:
  roll-dep src/third_party/ffmpeg

Bug: 1208571
Change-Id: Ic6ad98c4ebce1f2f2967f920dbe3fefca169a3ce
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/2965899
Reviewed-by: Frank Liberato <liberato@chromium.org>
Commit-Queue: Ted Meyer <tmathmeyer@chromium.org>
Cr-Commit-Position: refs/heads/master@{#893698}
---
 media/cast/test/fake_media_source.cc          |  4 +--
 .../clear_key_cdm/ffmpeg_cdm_audio_decoder.cc | 19 +++++++------
 media/ffmpeg/ffmpeg_common.h                  |  3 +-
 media/ffmpeg/ffmpeg_deleters.h                |  6 ++--
 .../filters/android/video_frame_extractor.cc  |  2 +-
 media/filters/audio_decoder_unittest.cc       |  2 +-
 media/filters/audio_file_reader.cc            |  2 +-
 ...ffmpeg_aac_bitstream_converter_unittest.cc | 10 +++----
 media/filters/ffmpeg_audio_decoder.cc         | 27 +++++++++---------
 media/filters/ffmpeg_demuxer.cc               | 18 ++++++++----
 media/filters/ffmpeg_demuxer.h                |  4 +++
 media/filters/ffmpeg_glue.cc                  |  3 --
 ...to_annex_b_bitstream_converter_unittest.cc |  6 ++--
 media/filters/ffmpeg_video_decoder.cc         | 28 ++++++++++---------
 media/filters/media_file_checker.cc           |  2 +-
 15 files changed, 70 insertions(+), 64 deletions(-)

diff --git a/media/cast/test/fake_media_source.cc b/media/cast/test/fake_media_source.cc
index 64dfac9fbc7bb..a98b2e49f5c56 100644
--- a/media/cast/test/fake_media_source.cc
+++ b/media/cast/test/fake_media_source.cc
@@ -141,7 +141,7 @@ void FakeMediaSource::SetSourceFile(const base::FilePath& video_file,
       continue;
     }
 
-    AVCodec* av_codec = avcodec_find_decoder(av_codec_context->codec_id);
+    const AVCodec* av_codec = avcodec_find_decoder(av_codec_context->codec_id);
 
     if (!av_codec) {
       LOG(ERROR) << "Cannot find decoder for the codec: "
@@ -432,7 +432,7 @@ void FakeMediaSource::Rewind() {
 }
 
 ScopedAVPacket FakeMediaSource::DemuxOnePacket(bool* audio) {
-  ScopedAVPacket packet(new AVPacket());
+  ScopedAVPacket packet = MakeScopedAVPacket();
   if (av_read_frame(av_format_context_, packet.get()) < 0) {
     VLOG(1) << "Failed to read one AVPacket.";
     packet.reset();
diff --git a/media/cdm/library_cdm/clear_key_cdm/ffmpeg_cdm_audio_decoder.cc b/media/cdm/library_cdm/clear_key_cdm/ffmpeg_cdm_audio_decoder.cc
index 332063530195a..e0a868fe64d94 100644
--- a/media/cdm/library_cdm/clear_key_cdm/ffmpeg_cdm_audio_decoder.cc
+++ b/media/cdm/library_cdm/clear_key_cdm/ffmpeg_cdm_audio_decoder.cc
@@ -168,7 +168,7 @@ bool FFmpegCdmAudioDecoder::Initialize(
   if (codec_context_->sample_fmt == AV_SAMPLE_FMT_S16P)
     codec_context_->request_sample_fmt = AV_SAMPLE_FMT_S16;
 
-  AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
+  const AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
   if (!codec || avcodec_open2(codec_context_.get(), codec, NULL) < 0) {
     DLOG(ERROR) << "Could not initialize audio decoder: "
                 << codec_context_->codec_id;
@@ -235,15 +235,16 @@ cdm::Status FFmpegCdmAudioDecoder::DecodeBuffer(
   size_t total_size = 0u;
   std::vector<std::unique_ptr<AVFrame, ScopedPtrAVFreeFrame>> audio_frames;
 
-  AVPacket packet;
-  av_init_packet(&packet);
-  packet.data = const_cast<uint8_t*>(compressed_buffer);
-  packet.size = compressed_buffer_size;
+  AVPacket* packet = av_packet_alloc();
+  packet->data = const_cast<uint8_t*>(compressed_buffer);
+  packet->size = compressed_buffer_size;
 
-  switch (decoding_loop_->DecodePacket(
-      &packet, base::BindRepeating(&FFmpegCdmAudioDecoder::OnNewFrame,
-                                   base::Unretained(this), &total_size,
-                                   &audio_frames))) {
+  FFmpegDecodingLoop::DecodeStatus decode_status = decoding_loop_->DecodePacket(
+      packet,
+      base::BindRepeating(&FFmpegCdmAudioDecoder::OnNewFrame,
+                          base::Unretained(this), &total_size, &audio_frames));
+  av_packet_free(&packet);
+  switch (decode_status) {
     case FFmpegDecodingLoop::DecodeStatus::kSendPacketFailed:
       return cdm::kDecodeError;
     case FFmpegDecodingLoop::DecodeStatus::kFrameProcessingFailed:
diff --git a/media/ffmpeg/ffmpeg_common.h b/media/ffmpeg/ffmpeg_common.h
index 2734a485cbd18..cede8ac5a7900 100644
--- a/media/ffmpeg/ffmpeg_common.h
+++ b/media/ffmpeg/ffmpeg_common.h
@@ -53,8 +53,7 @@ inline void ScopedPtrAVFree::operator()(void* x) const {
 
 inline void ScopedPtrAVFreePacket::operator()(void* x) const {
   AVPacket* packet = static_cast<AVPacket*>(x);
-  av_packet_unref(packet);
-  delete packet;
+  av_packet_free(&packet);
 }
 
 inline void ScopedPtrAVFreeContext::operator()(void* x) const {
diff --git a/media/ffmpeg/ffmpeg_deleters.h b/media/ffmpeg/ffmpeg_deleters.h
index 3429e05c7a699..9109dd23b2a01 100644
--- a/media/ffmpeg/ffmpeg_deleters.h
+++ b/media/ffmpeg/ffmpeg_deleters.h
@@ -18,9 +18,9 @@ struct ScopedPtrAVFree {
   void operator()(void* x) const;
 };
 
-// This assumes that the AVPacket being captured was allocated outside of
-// FFmpeg via the new operator.  Do not use this with AVPacket instances that
-// are allocated via malloc() or av_malloc().
+// This assumes that the ScopedAVPacket was created using MakeScopedAVPacket
+// from ffmpeg_demuxer.h. Do not use this with an AVPacket instance that was
+// allocated with new or manually av_malloc'd.
 struct ScopedPtrAVFreePacket {
   void operator()(void* x) const;
 };
diff --git a/media/filters/android/video_frame_extractor.cc b/media/filters/android/video_frame_extractor.cc
index c5529701075f2..bcce72026e470 100644
--- a/media/filters/android/video_frame_extractor.cc
+++ b/media/filters/android/video_frame_extractor.cc
@@ -119,7 +119,7 @@ void VideoFrameExtractor::ConvertPacket(AVPacket* packet) {
 
 ScopedAVPacket VideoFrameExtractor::ReadVideoFrame() {
   AVFormatContext* format_context = glue_->format_context();
-  ScopedAVPacket packet(new AVPacket());
+  ScopedAVPacket packet = MakeScopedAVPacket();
   while (av_read_frame(format_context, packet.get()) >= 0) {
     // Skip frames from streams other than video.
     if (packet->stream_index != video_stream_index_)
diff --git a/media/filters/audio_decoder_unittest.cc b/media/filters/audio_decoder_unittest.cc
index 6abf4283f02b5..127855d41f930 100644
--- a/media/filters/audio_decoder_unittest.cc
+++ b/media/filters/audio_decoder_unittest.cc
@@ -109,7 +109,7 @@ void SetDiscardPadding(AVPacket* packet,
   }
 
   // If the timestamp is positive, try to use FFmpeg's discard data.
-  int skip_samples_size = 0;
+  size_t skip_samples_size = 0;
   const uint32_t* skip_samples_ptr =
       reinterpret_cast<const uint32_t*>(av_packet_get_side_data(
           packet, AV_PKT_DATA_SKIP_SAMPLES, &skip_samples_size));
diff --git a/media/filters/audio_file_reader.cc b/media/filters/audio_file_reader.cc
index 87134e89530aa..94a4a72279c09 100644
--- a/media/filters/audio_file_reader.cc
+++ b/media/filters/audio_file_reader.cc
@@ -86,7 +86,7 @@ bool AudioFileReader::OpenDemuxer() {
 }
 
 bool AudioFileReader::OpenDecoder() {
-  AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
+  const AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
   if (codec) {
     // MP3 decodes to S16P which we don't support, tell it to use S16 instead.
     if (codec_context_->sample_fmt == AV_SAMPLE_FMT_S16P)
diff --git a/media/filters/ffmpeg_aac_bitstream_converter_unittest.cc b/media/filters/ffmpeg_aac_bitstream_converter_unittest.cc
index ac8bb13571759..045042ea63ceb 100644
--- a/media/filters/ffmpeg_aac_bitstream_converter_unittest.cc
+++ b/media/filters/ffmpeg_aac_bitstream_converter_unittest.cc
@@ -59,7 +59,7 @@ TEST_F(FFmpegAACBitstreamConverterTest, Conversion_Success) {
     dummy_packet[i] = i & 0xFF; // Repeated sequences of 0-255
   }
 
-  ScopedAVPacket test_packet(new AVPacket());
+  ScopedAVPacket test_packet = MakeScopedAVPacket();
   CreatePacket(test_packet.get(), dummy_packet,
                sizeof(dummy_packet));
 
@@ -91,7 +91,7 @@ TEST_F(FFmpegAACBitstreamConverterTest, Conversion_FailureNullParams) {
   EXPECT_FALSE(converter.ConvertPacket(NULL));
 
   // Create new packet to test actual conversion.
-  ScopedAVPacket test_packet(new AVPacket());
+  ScopedAVPacket test_packet = MakeScopedAVPacket();
   CreatePacket(test_packet.get(), dummy_packet, sizeof(dummy_packet));
 
   // Try out the actual conversion. This should fail due to missing extradata.
@@ -103,7 +103,7 @@ TEST_F(FFmpegAACBitstreamConverterTest, Conversion_AudioProfileType) {
 
   uint8_t dummy_packet[1000] = {0};
 
-  ScopedAVPacket test_packet(new AVPacket());
+  ScopedAVPacket test_packet = MakeScopedAVPacket();
   CreatePacket(test_packet.get(), dummy_packet,
                sizeof(dummy_packet));
 
@@ -142,7 +142,7 @@ TEST_F(FFmpegAACBitstreamConverterTest, Conversion_MultipleLength) {
 
   uint8_t dummy_packet[1000];
 
-  ScopedAVPacket test_packet(new AVPacket());
+  ScopedAVPacket test_packet = MakeScopedAVPacket();
   CreatePacket(test_packet.get(), dummy_packet,
                sizeof(dummy_packet));
 
@@ -158,7 +158,7 @@ TEST_F(FFmpegAACBitstreamConverterTest, Conversion_MultipleLength) {
   EXPECT_EQ(frame_length, test_packet->size);
 
   // Create a second packet that is 1 byte smaller than the first one
-  ScopedAVPacket second_test_packet(new AVPacket());
+  ScopedAVPacket second_test_packet = MakeScopedAVPacket();
   CreatePacket(second_test_packet.get(), dummy_packet,
                sizeof(dummy_packet) - 1);
 
diff --git a/media/filters/ffmpeg_audio_decoder.cc b/media/filters/ffmpeg_audio_decoder.cc
index 334958780f919..f860ead2afcf1 100644
--- a/media/filters/ffmpeg_audio_decoder.cc
+++ b/media/filters/ffmpeg_audio_decoder.cc
@@ -167,26 +167,27 @@ void FFmpegAudioDecoder::DecodeBuffer(const DecoderBuffer& buffer,
 }
 
 bool FFmpegAudioDecoder::FFmpegDecode(const DecoderBuffer& buffer) {
-  AVPacket packet;
-  av_init_packet(&packet);
+  AVPacket* packet = av_packet_alloc();
   if (buffer.end_of_stream()) {
-    packet.data = NULL;
-    packet.size = 0;
+    packet->data = NULL;
+    packet->size = 0;
   } else {
-    packet.data = const_cast<uint8_t*>(buffer.data());
-    packet.size = buffer.data_size();
+    packet->data = const_cast<uint8_t*>(buffer.data());
+    packet->size = buffer.data_size();
 
-    DCHECK(packet.data);
-    DCHECK_GT(packet.size, 0);
+    DCHECK(packet->data);
+    DCHECK_GT(packet->size, 0);
   }
 
   bool decoded_frame_this_loop = false;
   // base::Unretained and std::cref are safe to use with the callback given
   // to DecodePacket() since that callback is only used the function call.
-  switch (decoding_loop_->DecodePacket(
-      &packet, base::BindRepeating(&FFmpegAudioDecoder::OnNewFrame,
-                                   base::Unretained(this), std::cref(buffer),
-                                   &decoded_frame_this_loop))) {
+  FFmpegDecodingLoop::DecodeStatus decode_status = decoding_loop_->DecodePacket(
+      packet, base::BindRepeating(&FFmpegAudioDecoder::OnNewFrame,
+                                  base::Unretained(this), std::cref(buffer),
+                                  &decoded_frame_this_loop));
+  av_packet_free(&packet);
+  switch (decode_status) {
     case FFmpegDecodingLoop::DecodeStatus::kSendPacketFailed:
       MEDIA_LOG(ERROR, media_log_)
           << "Failed to send audio packet for decoding: "
@@ -330,7 +331,7 @@ bool FFmpegAudioDecoder::ConfigureDecoder(const AudioDecoderConfig& config) {
     }
   }
 
-  AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
+  const AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
   if (!codec ||
       avcodec_open2(codec_context_.get(), codec, &codec_options) < 0) {
     DLOG(ERROR) << "Could not initialize audio decoder: "
diff --git a/media/filters/ffmpeg_demuxer.cc b/media/filters/ffmpeg_demuxer.cc
index 9dfa1ddee8918..ac4713b072684 100644
--- a/media/filters/ffmpeg_demuxer.cc
+++ b/media/filters/ffmpeg_demuxer.cc
@@ -50,6 +50,7 @@
 #include "media/formats/webm/webm_crypto_helpers.h"
 #include "media/media_buildflags.h"
 #include "third_party/ffmpeg/ffmpeg_features.h"
+#include "third_party/ffmpeg/libavcodec/packet.h"
 
 #if BUILDFLAG(ENABLE_PLATFORM_HEVC)
 #include "media/filters/ffmpeg_h265_to_annex_b_bitstream_converter.h"
@@ -66,6 +67,11 @@ void SetAVStreamDiscard(AVStream* stream, AVDiscard discard) {
 
 }  // namespace
 
+ScopedAVPacket MakeScopedAVPacket() {
+  ScopedAVPacket packet(av_packet_alloc());
+  return packet;
+}
+
 static base::Time ExtractTimelineOffset(
     container_names::MediaContainerName container,
     const AVFormatContext* format_context) {
@@ -421,11 +427,11 @@ void FFmpegDemuxerStream::EnqueuePacket(ScopedAVPacket packet) {
   scoped_refptr<DecoderBuffer> buffer;
 
   if (type() == DemuxerStream::TEXT) {
-    int id_size = 0;
+    size_t id_size = 0;
     uint8_t* id_data = av_packet_get_side_data(
         packet.get(), AV_PKT_DATA_WEBVTT_IDENTIFIER, &id_size);
 
-    int settings_size = 0;
+    size_t settings_size = 0;
     uint8_t* settings_data = av_packet_get_side_data(
         packet.get(), AV_PKT_DATA_WEBVTT_SETTINGS, &settings_size);
 
@@ -437,7 +443,7 @@ void FFmpegDemuxerStream::EnqueuePacket(ScopedAVPacket packet) {
     buffer = DecoderBuffer::CopyFrom(packet->data, packet->size,
                                      side_data.data(), side_data.size());
   } else {
-    int side_data_size = 0;
+    size_t side_data_size = 0;
     uint8_t* side_data = av_packet_get_side_data(
         packet.get(), AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL, &side_data_size);
 
@@ -498,7 +504,7 @@ void FFmpegDemuxerStream::EnqueuePacket(ScopedAVPacket packet) {
                                        packet->size - data_offset);
     }
 
-    int skip_samples_size = 0;
+    size_t skip_samples_size = 0;
     const uint32_t* skip_samples_ptr =
         reinterpret_cast<const uint32_t*>(av_packet_get_side_data(
             packet.get(), AV_PKT_DATA_SKIP_SAMPLES, &skip_samples_size));
@@ -1788,9 +1794,9 @@ void FFmpegDemuxer::ReadFrameIfNeeded() {
   }
 
   // Allocate and read an AVPacket from the media. Save |packet_ptr| since
-  // evaluation order of packet.get() and base::Passed(&packet) is
+  // evaluation order of packet.get() and std::move(&packet) is
   // undefined.
-  ScopedAVPacket packet(new AVPacket());
+  ScopedAVPacket packet = MakeScopedAVPacket();
   AVPacket* packet_ptr = packet.get();
 
   pending_read_ = true;
diff --git a/media/filters/ffmpeg_demuxer.h b/media/filters/ffmpeg_demuxer.h
index b137a2b56853b..8d4c66e7611ac 100644
--- a/media/filters/ffmpeg_demuxer.h
+++ b/media/filters/ffmpeg_demuxer.h
@@ -62,6 +62,10 @@ class FFmpegGlue;
 
 typedef std::unique_ptr<AVPacket, ScopedPtrAVFreePacket> ScopedAVPacket;
 
+// Use av_packet_alloc() to create a packet, which is scoped to delete with
+// av_packet_free at the end of it's lifetime.
+MEDIA_EXPORT ScopedAVPacket MakeScopedAVPacket();
+
 class MEDIA_EXPORT FFmpegDemuxerStream : public DemuxerStream {
  public:
   // Attempts to create FFmpegDemuxerStream form the given AVStream. Will return
diff --git a/media/filters/ffmpeg_glue.cc b/media/filters/ffmpeg_glue.cc
index 53ec21394d7a1..b816aa5cd0cbf 100644
--- a/media/filters/ffmpeg_glue.cc
+++ b/media/filters/ffmpeg_glue.cc
@@ -89,9 +89,6 @@ FFmpegGlue::FFmpegGlue(FFmpegURLProtocol* protocol) {
   // Enable fast, but inaccurate seeks for MP3.
   format_context_->flags |= AVFMT_FLAG_FAST_SEEK;
 
-  // Ensures we can read out various metadata bits like vp8 alpha.
-  format_context_->flags |= AVFMT_FLAG_KEEP_SIDE_DATA;
-
   // Ensures format parsing errors will bail out. From an audit on 11/2017, all
   // instances were real failures. Solves bugs like http://crbug.com/710791.
   format_context_->error_recognition |= AV_EF_EXPLODE;
diff --git a/media/filters/ffmpeg_h264_to_annex_b_bitstream_converter_unittest.cc b/media/filters/ffmpeg_h264_to_annex_b_bitstream_converter_unittest.cc
index b869aa1bff694..1c71d205e3eea 100644
--- a/media/filters/ffmpeg_h264_to_annex_b_bitstream_converter_unittest.cc
+++ b/media/filters/ffmpeg_h264_to_annex_b_bitstream_converter_unittest.cc
@@ -304,7 +304,7 @@ class FFmpegH264ToAnnexBBitstreamConverterTest : public testing::Test {
 TEST_F(FFmpegH264ToAnnexBBitstreamConverterTest, Conversion_Success) {
   FFmpegH264ToAnnexBBitstreamConverter converter(&test_parameters_);
 
-  ScopedAVPacket test_packet(new AVPacket());
+  ScopedAVPacket test_packet = MakeScopedAVPacket();
   CreatePacket(test_packet.get(), kPacketDataOkWithFieldLen4,
                sizeof(kPacketDataOkWithFieldLen4));
 
@@ -319,7 +319,7 @@ TEST_F(FFmpegH264ToAnnexBBitstreamConverterTest, Conversion_SuccessBigPacket) {
   FFmpegH264ToAnnexBBitstreamConverter converter(&test_parameters_);
 
   // Create new packet with 1000 excess bytes.
-  ScopedAVPacket test_packet(new AVPacket());
+  ScopedAVPacket test_packet = MakeScopedAVPacket();
   static uint8_t excess_data[sizeof(kPacketDataOkWithFieldLen4) + 1000] = {0};
   memcpy(excess_data, kPacketDataOkWithFieldLen4,
          sizeof(kPacketDataOkWithFieldLen4));
@@ -343,7 +343,7 @@ TEST_F(FFmpegH264ToAnnexBBitstreamConverterTest, Conversion_FailureNullParams) {
   EXPECT_FALSE(converter.ConvertPacket(nullptr));
 
   // Create new packet to test actual conversion.
-  ScopedAVPacket test_packet(new AVPacket());
+  ScopedAVPacket test_packet = MakeScopedAVPacket();
   CreatePacket(test_packet.get(), kPacketDataOkWithFieldLen4,
                sizeof(kPacketDataOkWithFieldLen4));
 
diff --git a/media/filters/ffmpeg_video_decoder.cc b/media/filters/ffmpeg_video_decoder.cc
index f59ecbca2fe41..5aba5f0094772 100644
--- a/media/filters/ffmpeg_video_decoder.cc
+++ b/media/filters/ffmpeg_video_decoder.cc
@@ -339,25 +339,27 @@ FFmpegVideoDecoder::~FFmpegVideoDecoder() {
 bool FFmpegVideoDecoder::FFmpegDecode(const DecoderBuffer& buffer) {
   // Create a packet for input data.
   // Due to FFmpeg API changes we no longer have const read-only pointers.
-  AVPacket packet;
-  av_init_packet(&packet);
+  // av_init_packet is deprecated and being removed, and ffmpeg clearly does
+  // not want to allow on-stack allocation of AVPackets.
+  AVPacket* packet = av_packet_alloc();
   if (buffer.end_of_stream()) {
-    packet.data = NULL;
-    packet.size = 0;
+    packet->data = NULL;
+    packet->size = 0;
   } else {
-    packet.data = const_cast<uint8_t*>(buffer.data());
-    packet.size = buffer.data_size();
+    packet->data = const_cast<uint8_t*>(buffer.data());
+    packet->size = buffer.data_size();
 
-    DCHECK(packet.data);
-    DCHECK_GT(packet.size, 0);
+    DCHECK(packet->data);
+    DCHECK_GT(packet->size, 0);
 
     // Let FFmpeg handle presentation timestamp reordering.
     codec_context_->reordered_opaque = buffer.timestamp().InMicroseconds();
   }
-
-  switch (decoding_loop_->DecodePacket(
-      &packet, base::BindRepeating(&FFmpegVideoDecoder::OnNewFrame,
-                                   base::Unretained(this)))) {
+  FFmpegDecodingLoop::DecodeStatus decode_status = decoding_loop_->DecodePacket(
+      packet, base::BindRepeating(&FFmpegVideoDecoder::OnNewFrame,
+                                  base::Unretained(this)));
+  av_packet_free(&packet);
+  switch (decode_status) {
     case FFmpegDecodingLoop::DecodeStatus::kSendPacketFailed:
       MEDIA_LOG(ERROR, media_log_)
           << "Failed to send video packet for decoding: "
@@ -424,7 +426,7 @@ bool FFmpegVideoDecoder::ConfigureDecoder(const VideoDecoderConfig& config,
   if (decode_nalus_)
     codec_context_->flags2 |= AV_CODEC_FLAG2_CHUNKS;
 
-  AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
+  const AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
   if (!codec || avcodec_open2(codec_context_.get(), codec, NULL) < 0) {
     ReleaseFFmpegResources();
     return false;
diff --git a/media/filters/media_file_checker.cc b/media/filters/media_file_checker.cc
index a0f2848bbc68b..12e78e39e2d16 100644
--- a/media/filters/media_file_checker.cc
+++ b/media/filters/media_file_checker.cc
@@ -68,7 +68,7 @@ bool MediaFileChecker::Start(base::TimeDelta check_time) {
       auto context = AVStreamToAVCodecContext(format_context->streams[i]);
       if (!context)
         continue;
-      AVCodec* codec = avcodec_find_decoder(cp->codec_id);
+      const AVCodec* codec = avcodec_find_decoder(cp->codec_id);
       if (codec && avcodec_open2(context.get(), codec, nullptr) >= 0) {
         auto loop = std::make_unique<FFmpegDecodingLoop>(context.get());
         stream_contexts[i] = {std::move(context), std::move(loop)};
